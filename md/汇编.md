# 汇编

***

## 什么是汇编？

介绍汇编的话，可以从两条路来介绍。

第一条路是从高级语言开始，学过C语言的人可以看看这条路。

在C语言里我们写的代码其实和最终执行的东西是有天差地别的，虽然C语言写着和我们平常说的语言仍然有较大的不同，但是较之机器能读懂的语言，还是高到不知哪里。我们写的代码先被预处理，然后转换为汇编代码，然后生成可重定向文件，最后再和基本库进行链接操作。

比如一段代码：

```C
#include <stdio.h>
int main(){
    int a = 1;
    int b = a + 2;
    printf("a:%d\nb:%d\n", a, b);
    getchar();
    return 0;
}
```

被一个比较古老的编译器版本编译成汇编语言是长成这样子的：

```assembly
.LC0:
        .string "a:%d\nb:%d\n"
main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 16
        mov     DWORD PTR [rbp-4], 1
        mov     eax, DWORD PTR [rbp-4]
        add     eax, 2
        mov     DWORD PTR [rbp-8], eax
        mov     edx, DWORD PTR [rbp-8]
        mov     eax, DWORD PTR [rbp-4]
        mov     esi, eax
        mov     edi, OFFSET FLAT:.LC0
        mov     eax, 0
        call    printf
        call    getchar
        mov     eax, 0
        leave
        ret
```

我们可以看到，printf函数的格式化字符串被存在了一个单独的区域，每一个单独的区域其实就可以称为一个**段**，这个段不是说系统内部天然就存在这些段，而是为了方便程序运行，查找数据单独分割出来了一个个段。

一般来说，像这样的不可变字符串一般被存在只读段内，这样的段可能会被命名为.rodata,这也就是为什么下面的代码运行会报错：

```c
int main(){
    char* str = "hello world";
    str[0] = 'a';
    return 0;
}
```



因为字符串hello world其实是被分配在只读段内的，无法进行写操作，自然会出问题。

举这个例子是想说明一下为什么程序要分段。程序分段的好处非常的多，就不一一列举了。

当然除了像这样的只读段，程序中最基础的东西其实是代码段和数据段。

比如上面main下面的东西就是代码段。

学过C语言的话应该知道每个程序都应该有一个**入口点**，而在C语言里这个入口点被设定为main，其实main是一个包装过的入口点，也就是说真实的入口点其实还在main里面，叫做_start，正常写汇编程序的话就是以这个东西作为入口点的。

在介绍一下其他东西需要介绍一个其他的东西，是什么呢？

就是**寄存器**。C语言有变量的概念，我们的大部分操作其实都是对变量的操作，而CPU内部是存在寄存器的，简单来说这些是高速变量。当然我不是说寄存器完全对应了C语言中的变量，寄存器的数量有限，只有在用到的变量较少时才会只使用寄存器来存储变量。剩下的还是要在栈内或者堆内分配才行。

当然寄存器的地位并不完全相同，比如有的寄存器可以被拆分成两个寄存器使用而有的寄存器不能。像上面的汇编代码里带有b的寄存器rbp就是代表着栈基址的含义。

